import { FileChangeType, TextDocumentSyncKind, CodeActionTriggerKind, CodeActionKind, } from 'vscode-languageserver';
import { GetIRRequest } from './messages.cjs';
export const capabilities = {
    textDocumentSync: TextDocumentSyncKind.Full,
    completionProvider: {
        resolveProvider: true,
        // By default `@` won't trigger autocompletion, but it's an important character
        // for us since it signifies the beginning of an arg name.
        triggerCharacters: ['.', '@'],
    },
    referencesProvider: true,
    hoverProvider: true,
    codeActionProvider: {
        codeActionKinds: [CodeActionKind.QuickFix],
    },
    definitionProvider: true,
    workspaceSymbolProvider: true,
    renameProvider: {
        prepareProvider: true,
    },
};
export function bindLanguageServerPool({ connection, pool, openDocuments, configManager, }) {
    connection.onInitialize((config) => {
        if (config.initializationOptions?.typescript?.format) {
            configManager.updateTsJsFormatConfig('typescript', config.initializationOptions.typescript.format);
        }
        if (config.initializationOptions?.typescript?.preferences) {
            configManager.updateTsJsUserPreferences('typescript', config.initializationOptions.typescript.preferences);
        }
        if (config.initializationOptions?.javascript?.format) {
            configManager.updateTsJsFormatConfig('javascript', config.initializationOptions.javascript.format);
        }
        if (config.initializationOptions?.javascript?.preferences) {
            configManager.updateTsJsUserPreferences('javascript', config.initializationOptions.javascript.preferences);
        }
        return { capabilities };
    });
    openDocuments.onDidOpen(({ document }) => {
        pool.withServerForURI(document.uri, ({ server, scheduleDiagnostics }) => {
            server.openFile(document.uri, document.getText());
            scheduleDiagnostics();
        });
    });
    openDocuments.onDidClose(({ document }) => {
        pool.withServerForURI(document.uri, ({ server }) => {
            server.closeFile(document.uri);
        });
    });
    openDocuments.onDidChangeContent(({ document }) => {
        pool.withServerForURI(document.uri, ({ server, scheduleDiagnostics }) => {
            server.updateFile(document.uri, document.getText());
            scheduleDiagnostics();
        });
    });
    connection.onCodeAction(({ textDocument, range, context }) => {
        return pool.withServerForURI(textDocument.uri, ({ server }) => {
            // The user actually asked for the fix
            // @see https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#codeActionTriggerKind
            if (context.triggerKind === CodeActionTriggerKind.Invoked) {
                let language = server.getLanguageType(textDocument.uri);
                let formating = configManager.getFormatCodeSettingsFor(language);
                let preferences = configManager.getUserSettingsFor(language);
                let diagnostics = context.diagnostics;
                let kind = '';
                // QuickFix requests can have their `only` field set to `undefined`.
                // For what we've seen this is only true about `QuickFix`
                if (context.only === undefined) {
                    kind = CodeActionKind.QuickFix;
                }
                else if (context.only.includes(CodeActionKind.QuickFix)) {
                    // Otherwise we get the kind passed in the array.
                    // Because we only solicit for `CodeFix`s this array will only have
                    // a single entry in it.
                    kind = CodeActionKind.QuickFix;
                }
                return server.getCodeActions(textDocument.uri, kind, range, diagnostics, formating, preferences);
            }
            return [];
        });
    });
    connection.onPrepareRename(({ textDocument, position }) => {
        return pool.withServerForURI(textDocument.uri, ({ server }) => server.prepareRename(textDocument.uri, position));
    });
    connection.onRenameRequest(({ textDocument, position, newName }) => {
        return pool.withServerForURI(textDocument.uri, ({ server }) => server.getEditsForRename(textDocument.uri, position, newName));
    });
    connection.onCompletion(async ({ textDocument, position }) => {
        // Pause briefly to allow any editor change events to be transmitted as well.
        // VS Code explicitly sends the the autocomplete request BEFORE it sends the
        // document update notification.
        await new Promise((r) => setTimeout(r, 25));
        return pool.withServerForURI(textDocument.uri, ({ server }) => {
            let language = server.getLanguageType(textDocument.uri);
            let formatting = configManager.getFormatCodeSettingsFor(language);
            return server.getCompletions(textDocument.uri, position, formatting);
        });
    });
    connection.onCompletionResolve((item) => {
        // SAFETY: We should only ever get completion resolution requests for items we ourselves produced
        let glintItem = item;
        return (pool.withServerForURI(glintItem.data.uri, ({ server }) => {
            let language = server.getLanguageType(glintItem.data.uri);
            let formatting = configManager.getFormatCodeSettingsFor(language);
            let preferences = configManager.getUserSettingsFor(language);
            return server.getCompletionDetails(glintItem, formatting, preferences);
        }) ?? item);
    });
    connection.onHover(({ textDocument, position }) => {
        return pool.withServerForURI(textDocument.uri, ({ server }) => server.getHover(textDocument.uri, position));
    });
    connection.onDefinition(({ textDocument, position }) => {
        return pool.withServerForURI(textDocument.uri, ({ server }) => server.getDefinition(textDocument.uri, position));
    });
    connection.onReferences(({ textDocument, position }) => {
        return pool.withServerForURI(textDocument.uri, ({ server }) => server.getReferences(textDocument.uri, position));
    });
    connection.onWorkspaceSymbol(({ query }) => {
        let symbols = [];
        pool.forEachServer(({ server }) => {
            symbols.push(...server.findSymbols(query));
        });
        return symbols;
    });
    connection.onRequest(GetIRRequest.type, ({ uri }) => {
        return pool.withServerForURI(uri, ({ server }) => server.getTransformedContents(uri));
    });
    connection.onDidChangeWatchedFiles(({ changes }) => {
        pool.forEachServer(({ server, scheduleDiagnostics }) => {
            for (let change of changes) {
                if (change.type === FileChangeType.Created) {
                    server.watchedFileWasAdded(change.uri);
                }
                else if (change.type === FileChangeType.Deleted) {
                    server.watchedFileWasRemoved(change.uri);
                }
                else {
                    server.watchedFileDidChange(change.uri);
                }
            }
            scheduleDiagnostics();
        });
    });
}
//# sourceMappingURL=binding.js.map