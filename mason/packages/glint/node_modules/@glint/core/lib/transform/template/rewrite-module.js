import * as path from 'node:path';
import { assert } from '../util.js';
import TransformedModule from './transformed-module.js';
import { calculateTaggedTemplateSpans } from './inlining/tagged-strings.js';
import { calculateCompanionTemplateSpans } from './inlining/companion-file.js';
/**
 * Given the script and/or template that together comprise a component module,
 * returns a `TransformedModule` representing the combined result, with the
 * template(s), either alongside or inline, rewritten into equivalent TypeScript
 * in terms of the active glint environment's exported types.
 *
 * May return `null` if an unrecoverable parse error occurs or if there is
 * no transformation to be done.
 */
export function rewriteModule(ts, { script, template }, environment) {
    let { errors, directives, partialSpans } = calculateCorrelatedSpans(ts, script, template, environment);
    if (!partialSpans.length && !errors.length) {
        return null;
    }
    let sparseSpans = completeCorrelatedSpans(partialSpans);
    let { contents, correlatedSpans } = calculateTransformedSource(script, sparseSpans);
    globalThis.GLINT_DEBUG_IR?.(script.filename, contents);
    return new TransformedModule(contents, errors, directives, correlatedSpans);
}
/**
 * Locates any embedded templates in the given AST and returns a corresponding
 * `PartialReplacedSpan` for each, as well as any errors encountered. These
 * spans are then used in `rewriteModule` above to calculate the full set of
 * source-to-source location information as well as the final transformed source
 * string.
 */
function calculateCorrelatedSpans(ts, script, template, environment) {
    let directives = [];
    let errors = [];
    let partialSpans = [];
    let { ast, emitMetadata } = parseScript(ts, script, environment);
    ts.transform(ast, [
        (context) => function visit(node) {
            if (ts.isTaggedTemplateExpression(node)) {
                let meta = emitMetadata.get(node);
                let result = calculateTaggedTemplateSpans(ts, node, meta, script, environment);
                directives.push(...result.directives);
                errors.push(...result.errors);
                partialSpans.push(...result.partialSpans);
            }
            else if (ts.isModuleDeclaration(node)) {
                // don't traverse into declare module
                return node;
            }
            return ts.visitEachChild(node, visit, context);
        },
    ]);
    if (template) {
        let result = calculateCompanionTemplateSpans(ts, ast, script, template, environment);
        directives.push(...result.directives);
        errors.push(...result.errors);
        partialSpans.push(...result.partialSpans);
    }
    return { errors, directives, partialSpans };
}
function parseScript(ts, script, environment) {
    let { filename, contents } = script;
    let extension = path.extname(filename);
    let emitMetadata = new WeakMap();
    let setEmitMetadata = (node, data) => void emitMetadata.set(node, Object.assign(emitMetadata.get(node) ?? {}, data));
    let { preprocess, transform } = environment.getConfigForExtension(extension) ?? {};
    let preprocessed = preprocess?.(contents, filename) ?? { contents };
    let ast = ts.createSourceFile(filename, preprocessed.contents, ts.ScriptTarget.Latest, true // setParentNodes
    );
    if (transform) {
        let { transformed } = ts.transform(ast, [
            (context) => transform(preprocessed.data, { ts, context, setEmitMetadata }),
        ]);
        assert(transformed.length === 1 && ts.isSourceFile(transformed[0]));
        ast = transformed[0];
    }
    return { ast, emitMetadata };
}
/**
 * Given a sparse `CorrelatedSpan` array and the original source for a module,
 * returns the resulting full transformed source string for that module, as
 * well as a filled-in array of correlated spans that includes chunks of the
 * original source that were not transformed.
 */
function calculateTransformedSource(originalFile, sparseSpans) {
    let correlatedSpans = [];
    let originalOffset = 0;
    let transformedOffset = 0;
    for (let span of sparseSpans) {
        let interstitial = originalFile.contents.slice(originalOffset, span.insertionPoint);
        if (interstitial.length) {
            correlatedSpans.push({
                originalFile,
                originalStart: originalOffset,
                originalLength: interstitial.length,
                insertionPoint: originalOffset,
                transformedStart: transformedOffset,
                transformedLength: interstitial.length,
                transformedSource: interstitial,
            });
        }
        correlatedSpans.push(span);
        transformedOffset += interstitial.length + span.transformedLength;
        originalOffset +=
            interstitial.length + (span.originalFile === originalFile ? span.originalLength : 0);
    }
    let trailingContent = originalFile.contents.slice(originalOffset);
    correlatedSpans.push({
        originalFile,
        originalStart: originalOffset,
        originalLength: trailingContent.length + 1,
        insertionPoint: originalOffset,
        transformedStart: transformedOffset,
        transformedLength: trailingContent.length + 1,
        transformedSource: trailingContent,
    });
    return {
        contents: correlatedSpans.map((span) => span.transformedSource).join(''),
        correlatedSpans,
    };
}
/**
 * Given an array of `PartialCorrelatedSpan`s for a file, calculates
 * their `transformedLength` and `transformedStart` values, resulting
 * in full `ReplacedSpan`s.
 */
function completeCorrelatedSpans(partialSpans) {
    let replacedSpans = [];
    for (let i = 0; i < partialSpans.length; i++) {
        let current = partialSpans[i];
        let transformedLength = current.transformedSource.length;
        let transformedStart = current.insertionPoint;
        if (i > 0) {
            let previous = replacedSpans[i - 1];
            transformedStart =
                previous.transformedStart +
                    previous.transformedSource.length +
                    (current.insertionPoint - previous.insertionPoint - previous.originalLength);
        }
        replacedSpans.push({ ...current, transformedStart, transformedLength });
    }
    return replacedSpans;
}
//# sourceMappingURL=rewrite-module.js.map